export declare const workerCode = "\nself.addEventListener('install', (event) => {\n  self.skipWaiting();\n});\n\nself.addEventListener('activate', (event) => {\n  event.waitUntil(clients.claim());\n});\n\nself.addEventListener('message', (event) => {\n  if (event.data && event.data.type === 'PERFORMANCE_ENTRY') {\n    self.clients.matchAll().then(clients => {\n      clients.forEach(client => {\n        client.postMessage({\n          type: 'PERFORMANCE_ENTRY',\n          entry: event.data.entry\n        });\n      });\n    });\n  }\n});\n\nself.addEventListener('fetch', (event) => {\n  const request = event.request;\n  const startTime = performance.now();\n\n  event.respondWith(\n    fetch(request)\n      .then(async (response) => {\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n\n        // Clone the response to read headers\n        const clonedResponse = response.clone();\n        const headers = {};\n        clonedResponse.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n\n        // Create performance entry\n        const entry = {\n          name: request.url,\n          entryType: 'resource',\n          startTime: startTime,\n          duration: duration,\n          timing: {\n            fetchStart: startTime,\n            responseEnd: endTime\n          },\n          responseHeaders: headers,\n          request: {\n            type: request.type,\n            method: request.method,\n            mode: request.mode,\n            credentials: request.credentials,\n            headers: Object.fromEntries(request.headers)\n          }\n        };\n\n        // Send to main thread\n        self.clients.matchAll().then(clients => {\n          clients.forEach(client => {\n            client.postMessage({\n              type: 'PERFORMANCE_ENTRY',\n              entry\n            });\n          });\n        });\n\n        return response;\n      })\n      .catch((error) => {\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n\n        // Create error entry\n        const entry = {\n          name: request.url,\n          entryType: 'resource',\n          startTime: startTime,\n          duration: duration,\n          error: error.message,\n          request: {\n            type: request.type,\n            method: request.method,\n            mode: request.mode,\n            credentials: request.credentials,\n            headers: Object.fromEntries(request.headers)\n          }\n        };\n\n        // Send to main thread\n        self.clients.matchAll().then(clients => {\n          clients.forEach(client => {\n            client.postMessage({\n              type: 'PERFORMANCE_ENTRY',\n              entry\n            });\n          });\n        });\n\n        throw error;\n      })\n  );\n});\n";
